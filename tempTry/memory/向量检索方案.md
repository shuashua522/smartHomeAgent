### 方案 2：多向量空间（灵活加权，精度更高）

Qdrant 支持**多向量空间**（一个 Point 可存储多个向量，如`status_vec`、`cap_vec`等），检索时分别计算 4 个属性的相似度，再加权融合排序，适合需要动态调整属性权重的场景（如临时提高「位置」权重）。

#### 步骤 1：创建多向量集合

```python
# 定义4个向量空间（每个空间维度384）
vectors_config = {
    "status_vec": models.VectorParams(size=384, distance=models.Distance.COSINE),
    "cap_vec": models.VectorParams(size=384, distance=models.Distance.COSINE),
    "pref_vec": models.VectorParams(size=384, distance=models.Distance.COSINE),
    "loc_vec": models.VectorParams(size=384, distance=models.Distance.COSINE)
}

# 创建多向量集合
client.create_collection(
    collection_name="devices_multi_vec",
    vectors_config=vectors_config
)
```

#### 步骤 2：插入多向量数据

```python
for device in devices:
    # 每个属性单独向量化（与方案1一致）
    status_vec = embed_and_pool(device["status"]).tolist()
    cap_vec = embed_and_pool(device["capabilities"]).tolist()
    pref_vec = embed_and_pool(device["preferences"]).tolist()
    loc_vec = embed_and_pool(device["location"]).tolist()
    
    # 插入多向量Point
    client.upsert(
        collection_name="devices_multi_vec",
        points=[
            models.PointStruct(
                id=device["device_id"],
                vector={  # 对应多向量空间
                    "status_vec": status_vec,
                    "cap_vec": cap_vec,
                    "pref_vec": pref_vec,
                    "loc_vec": loc_vec
                },
                payload=device  # 保留原始属性
            )
        ]
    )
```

#### 步骤 3：多向量加权检索（核心）

```python
def search_multi_vec_devices(query_attrs, topk=5, dynamic_weights=None):
    # 默认权重（可动态调整）
    weights = dynamic_weights or {"status": 0.2, "capabilities": 0.3, "preferences": 0.2, "location": 0.3}
    
    # 1. 查询属性向量化
    query_vecs = {
        "status_vec": embed_and_pool(query_attrs["status"]).tolist(),
        "cap_vec": embed_and_pool(query_attrs["capabilities"]).tolist(),
        "pref_vec": embed_and_pool(query_attrs["preferences"]).tolist(),
        "loc_vec": embed_and_pool(query_attrs["location"]).tolist()
    }
    
    # 2. 分别查询4个向量空间，获取每个属性的相似度
    device_scores = {}
    for vec_name, query_vec in query_vecs.items():
        results = client.query_points(
            collection_name="devices_multi_vec",
            query=query_vec,
            vector_name=vec_name,  # 指定查询的向量空间
            limit=100,  # 先获取足够多的候选设备
            with_payload=False
        )
        # 记录每个设备在该属性的相似度
        for hit in results:
            if hit.id not in device_scores:
                device_scores[hit.id] = 0.0
            # 按权重累加相似度
            attr_name = vec_name.replace("_vec", "")  # status_vec → status
            device_scores[hit.id] += hit.score * weights[attr_name]
    
    # 3. 按综合得分排序，取TopK
    sorted_devices = sorted(device_scores.items(), key=lambda x: x[1], reverse=True)[:topk]
    
    # 4. 补充设备原始属性，返回结果
    final_results = []
    for device_id, total_score in sorted_devices:
        device_info = client.get_point(
            collection_name="devices_multi_vec",
            id=device_id,
            with_payload=True
        ).payload
        final_results.append({
            "device_id": device_id,
            "total_similarity": total_score,
            **device_info
        })
    return final_results

# 示例1：默认权重检索
top5_default = search_multi_vec_devices(query, topk=5)

# 示例2：动态提高「位置」权重（如紧急场景，位置优先）
dynamic_weights = {"status": 0.1, "capabilities": 0.2, "preferences": 0.1, "location": 0.6}
top5_location_priority = search_multi_vec_devices(query, topk=5, dynamic_weights=dynamic_weights)
```